(TODO)
Dependency injection, Unit testing, Queues, Real-time events, Notifications , Livewire , Inertia.js, Laravel vapor
routes => console.php / channels.php
---
Directory configuration:
Laravel should always be served out of the root of the "web directory" configured for your web server. 
i.e Public in root , other folders out of root attached  with index file
---

Application key : 
Setting application is important. If the application key is not set, your user sessions and other encrypted data will not be secure!

--- 
.env :
Environment file having the environment variables.

if (App::environment('local')) {
    // retrive any variable from environment
}
---

// You may easily access your configuration values using the global config helper function from anywhere in your application.
$value = config('app.timezone');

---
+++++++++++++++++++++++++++
php artisan config:cache
php artisan route:cache
++++++++++++++++++++++++++++
---

Maintenance mode:
When your application is in maintenance mode, a custom view will be displayed for all requests into your application.
---
command : php artisan down
revert mointenance mode : php artisan up

---
Laravel Directory Structure :

Root directory (That are in buit-in installed project )

Many of the classes in the app directory can be generated by Artisan via commands.

The App Directory
The Broadcasting Directory
The Console Directory
The Events Directory
The Exceptions Directory
The Http Directory
The Jobs Directory
The Listeners Directory
The Mail Directory
The Notifications Directory
The Policies Directory
The Providers Directory
The Rules Directory



---
(---ROOT DIRECTORY---) 

Routes:
++ web.php => manage sessions, csrf protection , routing for website
++ api.php => manage stateless part of application , does'nt manage session.
++ console.php => 
This file is where you may define all of your Closure based console
commands. Each Closure is bound to a command instance allowing a
simple approach to interacting with each command's 

E.g:

protected function commands()
{
    // Register a new command `say:hello` using the shorthand
    // syntax. This command will be registered automatically
    // and does not have to be explicitly registered.
    $this->command('say:hello {name}', function($name) {
        $this->info("Hello, {$name}");
    });
}

++ channels.php => 

The channels.php file is where you may register all of the event broadcasting channels that your application supports.


Storage Directory:

storage directory contains your compiled Blade templates, file based sessions, file caches, and other files generated by the framework.
++ app contains files generated by system like images , files , etc
++ frame work have framework generated files
++ logs directory contains your application's log files.


Test directory :
it contain automated test's.

Vendor:
The vendor directory contains your Composer dependencies.
----



(---APP DIRECTORY---) 



-------------
Deployement :

**When deploying your application to production, you should make sure that you run the config:cache Artisan command during your deployment process:

php artisan config:cache

**If you are building a large application with many routes, you should make sure that you are running the route:cache Artisan command during your deployment process:

php artisan route:cache


-----------






----------
The Basics : 

+++++++++++++++++++++++++++++++++++++++++++
1) Routing
+++++++++++++++++++++++++++++++++++++++++++


**) handle multiple request

Route::match(['get', 'post'], '/', function () {
    //
});
 
Route::any('/', function () {
    //
});


**) return view

If your route only needs to return a view, you may use the Route::view method. 
Like the redirect method, this method provides a simple shortcut so that you do not have to define a full route or controller. 
The view method accepts a URI as its first argument and a view name as its second argument.
 In addition, you may provide an array of data to pass to the view as an optional third argument:

Route::view('/welcome', 'welcome');
 
Route::view('/welcome', 'welcome', ['name' => 'Taylor']);

**) Required parameters

Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) {
    //
})

**) Optional Parameters
Occasionally you may need to specify a route parameter, but make the presence of that route parameter optional. You may do so by placing a ? mark after the parameter name. Make sure to give the route's corresponding variable a default value:

Route::get('user/{name?}', function ($name = null) {
    return $name;
});
 
Route::get('user/{name?}', function ($name = 'John') {
    return $name;
});



**) Regular expression routes

Route::get('user/{name}', function ($name) {
    //
})->where('name', '[A-Za-z]+');
 
Route::get('user/{id}', function ($id) {
    //
})->where('id', '[0-9]+');
 
Route::get('user/{id}/{name}', function ($id, $name) {
    //
})->where(['id' => '[0-9]+', 'name' => '[a-z]+'])



**) Named Routes
Named routes allow the convenient generation of URLs or redirects for specific routes.
You may specify a name for a route by chaining the name method onto the route definition:

Route::get('user/profile', function () {
    //
})->name('profile');


// Generating URLs...
$url = route('profile');
 
// Generating Redirects...
return redirect()->route('profile');


If the named route defines parameters, you may pass the parameters as the second argument to the route function. The given parameters will automatically be inserted into the URL in their correct positions:

Route::get('user/{id}/profile', function ($id) {
    //
})->name('profile');
 
$url = route('profile', ['id' => 1]);


**) Inspect current route

public function handle($request, Closure $next)
{
    if ($request->route()->named('profile')) {
        //
    }
 
    return $next($request);
}


**) Group URL's (namespace  &  prefix)

Route::namespace('Vendor')->group(function () {
Route::prefix('vendor')->group(function () {

//Anything

});
});


//middleware group

Route::middleware(['first', 'second'])->group(function () {

});


** ) Implicit Model Binding :

In this we inject the eloquent instance 

public function getUser(User $user){

	return $user;	
}

**) Explicit Model Binding : 

In this we specify the logic in Route service provider.
So when we hit a route we get the user instance with in.


** )  Fall back route  : When no other route is selected


Route::fallback(function () {
    //
});


**) Get current route details

$route = Route::current();
 
$name = Route::currentRouteName();
 
$action = Route::currentRouteAction();


**) Method spoofing

adding put , patch , delete methid in html form.

    <input type="hidden" name="_method" value="PUT">
    OR
     @method('PUT')


**) Rate limiting in route

// 60 call per 1 min

Route::middleware('auth:api', 'throttle:60,1')->group(function () {
    Route::get('/user', function () {
        //
    });
});


+++++++++++++++++++++++++++++++++++++++++++
2) Middleware
+++++++++++++++++++++++++++++++++++++++++++
 
** ) To create a new middleware, use the make:middleware Artisan command:

php artisan make:middleware CheckAge

If you would like to assign middleware to specific routes, you should first assign the middleware a key in your app/Http/Kernel.php 

Middleware can be define in 2 ways.

1) for every http request / we set it in  protected $middleware 

2) for specific routes (first we define it in kernal than use it in every route file) / we set it in protected $routeMiddleware
 
--
We can set middleware to single route 

Route::get('/', function () {
    //
})->middleware('web');

--
We can set middleware to groups

Route::group(['middleware' => ['web']], function () {
    //
});

--

we can also set priority of middleware in protected $middlewarePriority

+++++++++++++++++++++++++++++++++++++++++++
3) CSRF token
+++++++++++++++++++++++++++++++++++++++++++

Laravel makes it easy to protect your application from cross-site request forgery (CSRF) attacks.
Cross-site request forgeries are a type of malicious exploit whereby unauthorized commands are performed on behalf of an authenticated user.

--
X-CSRF-TOKEN :
In addition to checking for the CSRF token as a POST parameter,
the VerifyCsrfToken middleware will also check for the X-CSRF-TOKEN request header.
 You could, for example, store the token in an HTML meta tag:

<meta name="csrf-token" content="{{ csrf_token() }}">


+++++++++++++++++++++++++++++++++++++++++++
4) Controller's
+++++++++++++++++++++++++++++++++++++++++++


## single action controller 

php artisan make:controller ShowProfile --invokable

## assigning middleware

   public function __construct()
    {
        $this->middleware('auth');
 
        $this->middleware('log')->only('index');
 
        $this->middleware('subscribed')->except('store');
    }

## resource controller

php artisan make:controller PhotoController --resource

register multiple resource controller 

Route::resources([
    'photos' => 'PhotoController',
    'posts' => 'PostController'
]);


## route model binding

php artisan make:controller PhotoController --resource --model=Photo

## partial resorce controller

Route::resource('photos', 'PhotoController')->only(['index', 'show']);

## api resource controller
// exclude create , edit method which involve html templates
Route::apiResource('photos', 'PhotoController');


## add / except methods in 

Route::resource('photos', 'PhotoController')->only([
    'index', 'show'
]);
 
Route::resource('photos', 'PhotoController')->except([
    'create', 'store', 'update', 'destroy'
]);


## Route caching

php artisan route:cache

to clear

php artisan route:clear

+++++++++++++++++++++++++++++++++++++++++++
5) Request
+++++++++++++++++++++++++++++++++++++++++++
use Illuminate\Http\Request;

while working with requests

Some Important Request methods :
--------
$uri = $request->path();

-----
if ($request->is('admin/*')) {
    //
}

-------
// Without Query String...
$url = $request->url();
 ----
// With Query String...
$url = $request->fullUrl();
-----
$method = $request->method();
---- 
if ($request->isMethod('post')) {
    //
}

------
$input = $request->all();
$name = $request->input('name');
$name = $request->input('name', 'Sally');

-----
$input = $request->only(['username', 'password']);
 -----
$input = $request->only('username', 'password');
 -----
$input = $request->except(['credit_card']);
 ----
$input = $request->except('credit_card');
---
if ($request->has('name')) {
    //
}
---
if ($request->has(['name', 'email'])) {
    //
}
----
if ($request->filled('name')) {
    //
}
---
if ($request->missing('name')) {
    //
}

---
OLD INPUT

<input type="text" name="username" value="{{ old('username') }}">

------------
FILE
------------
$file = $request->file('photo');
-----------
$file = $request->photo;
-------------
if ($request->hasFile('photo')) {
    //
}
-------------
$path = $request->photo->path();
 ----------------
$extension = $request->photo->extension();
------------------
$path = $request->photo->store('images');
---------------- 
$path = $request->photo->store('images', 's3');
----------------
If you do not want a file name to be automatically generated,
you may use the storeAs method, which accepts the path, 
file name, and disk name as its arguments:
-----------------
$path = $request->photo->storeAs('images', 'filename.jpg');
-------------- 
$path = $request->photo->storeAs('images', 'filename.jpg', 's3');


+++++++++++++++++++++++++++++++++++++++++++
6) Response
+++++++++++++++++++++++++++++++++++++++++++


** ) Return any string , array 

Route::get('/', function () {
    return 'Hello World';
});


Route::get('/', function () {
    return [1, 2, 3];
});


**) Return with status code and header

Route::get('home', function () {
    return response('Hello World', 200)
                  ->header('Content-Type', 'text/plain');
});


return response($content)
            ->header('Content-Type', $type)
            ->header('X-Header-One', 'Header Value')
            ->header('X-Header-Two', 'Header Value');


return response($content)
            ->withHeaders([
                'Content-Type' => $type,
                'X-Header-One' => 'Header Value',
                'X-Header-Two' => 'Header Value',
            ]);

--
To resolve cors add this header





**) REDIRECTIONS


# via url

Route::get('dashboard', function () {
    return redirect('home/dashboard');
});


# return back with input

 Route::post('user/profile', function () {
    // Validate the request...
 
    return back()->withInput();
});


# with named routes

return redirect()->route('login');

# add params 

 return redirect()->route('profile', ['id' => 1]);

# redirect to route outside
 return redirect()->away('https://www.google.com');


# flash message's
--
controller
--
return redirect('dashboard')->with('status', 'Profile updated!');
--
view
--
@if (session('status'))
    <div class="alert alert-success">
        {{ session('status') }}
    </div>
@endif

---
Download Files


+++++++++++++++++++++++++++++++++++++++++++
6) Views
+++++++++++++++++++++++++++++++++++++++++++

##

 return view('greeting', ['name' => 'James']);


##

return view('admin.profile', $data);

## 

sharing data with all views

<?php
 
namespace App\Providers;
 
use Illuminate\Support\Facades\View;
 
class AppServiceProvider extends ServiceProvider
{
    /**
     * Register any application services.
     *
     * @return void
     */
    public function register()
    {
        //
    }
 
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        View::share('key', 'value');
    }



+++++++++++++++++++++++++++++++++++++++++++
6) URL
+++++++++++++++++++++++++++++++++++++++++++

accesing the url

// Get the current URL without the query string...
echo url()->current();
 
// Get the current URL including the query string...
echo url()->full();
 
// Get the full URL for the previous request...
echo url()->previous();


Each of these methods may also be accessed via the URL facade:

use Illuminate\Support\Facades\URL;
 
echo URL::current();

-- Signed routes

use Illuminate\Support\Facades\URL;
 
return URL::signedRoute('unsubscribe', ['user' => 1]);


-- If you would like to generate a temporary signed route URL that expires, you may use the temporarySignedRoute method:

use Illuminate\Support\Facades\URL;
 
return URL::temporarySignedRoute(
    'unsubscribe', now()->addMinutes(30), ['user' => 1]
);

// Named routes

Route::get('/post/{post}', function () {
    //
})->name('post.show');

echo route('post.show', ['post' => 1]);

+++++++++++++++++++++++++++++++++++++++++++
6) SESSION
+++++++++++++++++++++++++++++++++++++++++++

In two ways to work with session
1) global session helper Session
2) via $request


## REQUEST
// get and set
$request->session()->get('key');
$request->session()->put('key', 'value');
// default
$value = $request->session()->get('key', 'default');
// Forget a single key...
$request->session()->forget('key');
// Forget multiple keys...
$request->session()->forget(['key1', 'key2']);
// ALL
$request->session()->flush();


## Global session helper 
// get and set
$value = session('key');
Session::get('success')
session(['key' => 'value']);
Session::put('key', 'value');
//default
$value = session('key', 'default');
// delete
Session::forget('yourKeyGoesHere') 

## check if session exist 
if ($request->session()->exists('users')) {
    //
}

## check if session has values
if ($request->session()->has('users')) {
    //
}


## flash session (valid for only one request)
$request->session()->flash('status', 'Task was successful!');

+++++++++++++++++++++++++++++++++++++++++++
7) Exception handeling
+++++++++++++++++++++++++++++++++++++++++++



+++++++++++++++++++++++++++++++++++++++++++
8) LOG
+++++++++++++++++++++++++++++++++++++++++++
use Log;


Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);

OR

logger('stripe create customer api error: '.$th->getMessage());


